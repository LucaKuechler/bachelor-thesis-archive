"""
    Description: This tools pulls all Malwares for the current day from
    https://bazaar.abuse.ch/.
"""
import argparse
import io
import json
import random
from pathlib import Path
import zipfile
import requests

URL = "https://mb-api.abuse.ch/api/v1/"
LIMIT = 20


class Malware:
    def __init__(self, sha256: str, signature: list[str]) -> None:
        self.sha256: str = sha256
        self.signature: list[str] = signature

    def __str__(self) -> str:
        return f"(Malware: {self.sha256} | signatures: {self.signature})"

    def __repr__(self) -> str:
        return self.__str__()


def copy_malware_sample(from_zip: Path, to_zip: str, file: str):
    with zipfile.ZipFile(from_zip, "r") as zip_ref:
        extracted_data = zip_ref.read(file, pwd="infected".encode())

    # Create a new zip file in memory
    new_zip_data = io.BytesIO()
    with zipfile.ZipFile(new_zip_data, "w", zipfile.ZIP_DEFLATED) as zip_ref:
        # Add the extracted file to the new zip archive
        zip_ref.writestr(file, extracted_data)

    # Save the new zip file to disk or use it as needed
    with open(to_zip, "wb") as new_zip_file:
        new_zip_file.write(new_zip_data.getvalue())


def read_files_from_zip_archive(filepath: Path) -> list[tuple[str, Path]]:
    with zipfile.ZipFile(filepath, "r") as zip_file:
        # Get all file names in the zip file
        all_files = zip_file.namelist()
        print("all: ", len(all_files))

        # Filter for .exe files
        return [(file, filepath) for file in all_files if file.endswith(".exe")]


def get_zip_file_paths(directory) -> list[Path]:
    directory_path = Path(directory)
    zip_file_paths = list(directory_path.glob("**/*.zip"))
    return zip_file_paths


def collect_malware_info(sha256_hash: str, token: str) -> Malware:
    headers = {"API-KEY": token}

    data = {
        "query": "get_info",
        "hash": sha256_hash,
    }

    resp = requests.post(URL, data=data, timeout=15, headers=headers)
    data = resp.json()
    if resp.status_code != 200 or data.get("query_status") != "ok":
        raise Exception("Error: not 200 or wrong query status", resp.content)

    data = data.get("data")[0]
    return Malware(sha256=data.get("sha256_hash"), signature=data.get("signature"))


def write_in_output_file(outfile: str, malware: Malware):
    pass


def main(token: str, download: bool) -> None:
    # get all zip files inside the input directory
    zip_files = get_zip_file_paths("./input/")

    # retrieve all .exe files inside the zip
    files = []
    for zip in zip_files:
        files += read_files_from_zip_archive(zip)

    print("Num of .exe files: ", len(files))

    # select 100 random samples from the files list
    samples = random.sample(files, k=LIMIT)
    print(samples)

    # download selected samples
    if not download:
        return

    malware_informations = {}
    for i, sample in enumerate(samples, start=1):
        filename, zip_path = sample
        # collect more informations
        malware = collect_malware_info(filename[:-4], token)
        malware_informations[i] = {
            "sha256": malware.sha256,
            "signature": malware.signature,
        }

        # mv exe inside a password protected zip file inside the output dir
        copy_malware_sample(zip_path, f"./output/{filename[:-4]}.zip", filename)

    with open(f"output/malware.json", "w") as file:
        file.write(json.dumps(malware_informations, indent=4))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="ProgramName",
        description="What the program does",
        epilog="Text at the bottom of help",
    )

    parser.add_argument("-t", "--token", type=str, required=True)
    parser.add_argument("-d", "--download", action="store_true")
    args = parser.parse_args()

    main(args.token, args.download)
